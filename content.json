{"pages":[{"title":"","text":"google-site-verification: google54765e92939cdff8.html","link":"/google54765e92939cdff8.html"},{"title":"關於我","text":"Hi 我是 Andy這邊會隨手記錄一些我遇到的程式問題","link":"/about/index.html"}],"posts":[{"title":"Angular Lazy Loading","text":"在 Angular 應用程式一載入時，預設會將所有的 Module 一次全部載入，但如果今天應用程式規模很大，或是某些 Module 中需要載入的東西過多，就會拖到整個應用程式的載入時間。 為了解決這個問題，Angular 有針對 Module 提供 Lazy Loading 的功能，簡單來說就是當需要此 Module 的時候再進行載入，如此就不會影響到整個應用程式的效能。 實現方式透過 Angular Router 中內建的功能即可實現，步驟如下： 修改app-routing.module.ts 123456const routes: Routes = [ { path: 'customers', loadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule) }]; 利用loadChildren這個屬性，我們就可以透過 import 將我們想要 lazy loading 的 Module，在應用程式觸發到path中定義的路由(在這個例子中就是/customers)的時候將 CustomersModule 進行載入。 修改customers.module.ts 1234567891011import { CustomersRoutingModule } from './customers-routing.module';@NgModule({ declarations: [ CustomersComponent ], imports: [ CommonModule, CustomersRoutingModule ]}) 額外新增customers-routing.module.ts，並新增到 CustomersModule 的 imports 中，我們會將關於此 Module 下 Router 的設定拆出來放在這個檔案中。 新增customers-routing.module.ts 123456789101112const routes: Routes = [ { path: 'info', component: CustomersComponent }];@NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule]})export class CustomersRoutingModule { } 這邊我們就可以定義在子路徑下要載入哪個 Component，最終的路徑會是原本app-routing.module.ts中定義的path加上這邊定義的path，以上例來說就會是在/customers/info下讀取到 CustomersComponent。這邊要注意需要用forChild來定義子路由。 透過指令建立如果我們在一開始就決定要使用 lazy loading 的方式載入 Module，也可以選擇用以下指令直接建立好上述的元件： 1ng generate module customers --route customers --module app.module 實驗我們可以在customers.components.ts中加上console.log來實驗是否有 lazy loading 12345678export class CustomersComponent implements OnInit { constructor() { } ngOnInit() { console.log(\"Customers Component Init\"); }} 讀取 http://localhost:4200 讀取 http://localhost:4200/customers 注意事項 如果 Module 需要 lazy loading，需注意app.module.ts裡面不可以 import 到這個 Module，否則還是會在應用程式啟動時就載入。","link":"/2022/05/29/angular-lazy-loading/"},{"title":"Angular 取得元素 offsetWidth 時有誤解法","text":"今天在工作上遇到一個問題，我有一個功能執行時會切換兩個 Angular Component 的顯示，當切換到其中一個 Component 時，我會去抓取當下它的 offsetWidth 做運算使用，但抓這個 offsetWidth 卻憑空少了15px，後來在找了一段時間終於找到原因，在這邊以一個簡化過的例子紀錄一下。 範例連結：https://stackblitz.com/edit/angular-ivy-bmpsfk 問題假設有一個按鈕，點擊之後可依狀態顯示不同的 Component。 12345678&lt;div class=\"container\"&gt; &lt;app-first *ngIf=\"visibleComponent === 'first'; else second\"&gt;&lt;/app-first&gt; &lt;ng-template #second&gt; &lt;app-second&gt;&lt;/app-second&gt; &lt;/ng-template&gt;&lt;/div&gt;&lt;button (click)=\"switch()\"&gt;switch&lt;/button&gt; 在 first component 中我們嘗試取得該元素的offsetWidth。 1&lt;div #content&gt;first component&lt;/div&gt; 12345...ngAfterViewInit() { console.log('content width: ', this.content.nativeElement.offsetWidth);}... 結果在當由 second 切換到 first 時，取得的 offsetWidth 為624px，但實際應為639px，少了15px。 原因經過測試後發現當有載入BrowserAnimationsModule才會發生此問題，且是 second component 中有 scroll bar 的原因，導致在取得 offsetWidth 時少了 15px。 但明明我是在 first component 中取 offsetWidth 阿？怎麼會吃到 scroll bar？ 原來是在 ngAfterViewInit 執行的當下子 Component 的畫面會比父 Component 還早運算，我們 ngIf 的條件是寫在父 Component 進行判斷，所以當下吃到的父層寬度還會保留在切換到另一個 Component 之前。 子 Component 的 ngAfterViewInit 也會比父 Component 的同一個事件還早執行。 由於 second component 多了 scroll bar，且在載入BrowserAnimationsModule時 scroll bar 會被算成 15px 的空間，所以在取得 offsetWidth 會少了 scroll bar 佔去的寬度。 解法由於是執行順序的問題，所以最簡單的解法就是透過setTimeout將取得 offsetWidth 的動作強制移動置 event loop 的最後執行。 12345678910ngAfterViewInit() { console.log('content width: ', this.content.nativeElement.offsetWidth); setTimeout(() =&gt; { console.log( 'content width after: ', this.content.nativeElement.offsetWidth ); });} 執行結果 目前只有嘗試到這個方式，若有找到更好的寫法會再更新。","link":"/2022/06/01/angular-offsetwidth-bug/"},{"title":"探討 Angular Module","text":"Angular 本身的設計概念就是使用模組化的機制，Module (模組) 是組成 Angular 應用程式的基本單位，每個 Angular 專案最開始都會有一個模組當作程式進入點，稱為根模組(Root Module) 。透過 Angular CLI 創建的專案會將此根模組命名為AppModule，並放在app.module.ts檔案中。 也可以將有相同特性的功能拆出來，組合成不同的模組，各個模組間依程式架構相互引用，組合成 Angular 應用程式。模組中可以透過設定的方式，定義此模組中包含的 components、directives、pipes 等，以及其他與模組相關的屬性，以下我們就來研究一下 Angular Module 的使用方式以及使用情境。 組成12345678910@NgModule({ declarations: [ AppComponent, ], imports: [ BrowserModule, ], providers: [], bootstrap: [AppComponent]}) 定義模組的檔案中會包含@NgModule，用來定義模組的設定。主要包含以下幾個屬性： declarations用來宣告此模組中包含的 components、directives、pipes。 12345declarations: [ UserComponent, CustomPipe, FileDirective],; 若使用ng generate 指令來產生物件，Angular CLI 會自動幫你把物件加入 declarations 中。 imports想要額外載入的 module，載入後就可以使用該 module 中 exports 的物件。 1234imports: [ BrowserModule, UserModule], 如上例，只要 import UserModule，模組內就可以使用 UserModule 中 export 的所有物件。 根模組必須要 import BrowserModule。 其他模組必須要 import CommonModule。 只要是用 CLI 建立的，上述兩項都會自動 import。 exports要匯出給其他模組使用的物件。 12345678declarations: [ UserComponent, CustomPipe, FileDirective],;exports: [ UserComponent], 要 export 的物件必須存在於 declarations 或 import 的 Module 中才可以。 上例 export 的只有 UserComponent，因此引入此 module 的模組只可使用 UserComponent。 providers宣告可以依賴注入的 service，整個應用程式都可以使用到此處宣告的 service。 123providers: [ UserService], 關於 providers 會再整理一篇文章進行探討。 bootstrap1bootstrap: [AppComponent], 定義根元件，作為應用程式啟動後預設讀取的元件，只有根模組需要定義此屬性，一般不太需要更動。 使用情境Module 用法除了最基本會有的根模組(Root Module) 外，常見的還有以下兩種用法： Feature Module其實就是最常見、第一個會想到使用 Module 的情境。將應用程式中你認為可以額外拆出來撰寫成一個功能的程式片段，拆出來成為一個 Module，就會稱它為Feature Module。 例如假設今天要實作一個網頁聊天室，聊天室可以傳送的訊息種類分為文字、檔案、圖片、貼圖等，我們就可以把傳送的「訊息」 拆一個 MessageModule，裡面包含 TextComponent、FileComponent、ImageComponent … 與其他串接的 Service 等。 Shared Module在 Angular 中常常會遇到很多物件(component、directive、pipe)一直被重複使用，此時為了不讓這些物件散落各地，還要讓 Module 一直引用來引用去，通常可以建立一個Shared Module來統一管理這些物件，要使用這些物件的 Module 只需要匯入一個Shared Module就可以了。 12345678910111213@NgModule({ declarations: [ TableComponent, PagerComponent, PaginationComponent ], exports: [ TableComponent, PagerComponent, PaginationComponent ],})export class SharedModule {} 如上例，其他模組只需要 import SharedModule 就可以使用裡面的所有物件。","link":"/2022/05/28/angular-module/"},{"title":"position:sticky 遇到 overflow 時失效解法","text":"今天在處理將 table 表頭凍結在最上方時，找到了使用position: sticky的方式解決，但若我要同時在小畫面時讓這個 table 的 X 軸能夠有 scroll bar 卻出現了問題，以下紀錄一下問題原因與解決方式。 範例連結：https://codepen.io/andyhung0723/pen/YzeOovW 問題假設我有一個 table，若我想將它的表頭凍結在最上方不動，可以使用position: sticky： 1234.table-sticky .th { position: sticky; top: 0;} 若在小畫面時想要此 table 不要撐開整體寬度，一般會在外層使用overflow-x: auto來讓 X 軸產生 scroll bar： 123.table-sticky-container { overflow-x: auto;} 此時就會發現原本position: sticky的凍結效果卻失效了。 原因經測試發現只要position: sticky上所有階層的父元素只要有一個的overflow值是visible以外的其他值，就會導致失效。 解法目前單純使用 CSS 貌似沒有解法，因此我使用 JavaScript 的 scroll 事件來動態 transform 表頭的位置來解決，程式碼如下： 12345678910111213141516171819202122window.addEventListener('scroll', function(event) { var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var stickyTables = document.querySelectorAll('.table-sticky'); for(var i = 0 ; i &lt; stickyTables.length ; i++) { var thead = stickyTables[i].querySelector('thead'); var offsetTop = stickyTables[i].offsetTop; var offsetHeight = stickyTables[i].offsetHeight - thead.offsetHeight; var transformY = getTranslateY(thead); if(scrollTop &gt;= offsetTop &amp;&amp; scrollTop &lt;= offsetTop + offsetHeight) { transformY = scrollTop - offsetTop; }else if(scrollTop &lt; offsetTop){ transformY = 0; } thead.style.transform = 'translateY('+ transformY +'px)'; } });function getTranslateY(element) { var style = window.getComputedStyle(element); var matrix = new WebKitCSSMatrix(style.transform); return matrix.m42;}","link":"/2022/06/08/position-sticky-issue/"},{"title":"Google 官方正式宣布「項目範圍的自訂維度 (item scope)」上線啦!","text":"👉 文章內容深度 : 3/5顆星👉 適用對象 : GA4 有做電子商務事件 ▶ 什麼是項目範圍自訂維度(item scope) ?項目範圍的維度，是指專門用來追蹤 GA4 電子商務事件中商品的資訊，例如 : 商品名稱、商品id、顏色、尺寸、重量等等。在項目範圍的維度中，有分 GA4 預設維度 &amp; 最近才公布的自訂維度。舉例來說 :GA4 預設維度 : 商品名稱(item_name)、商品編號(item_id)、商品價格(price)等等。官方文件自訂維度 : 用來補足 GA4 預設維度中沒有的維度，由自己定義，例如 : 課程長度、售票種類、商品關鍵字等等。數量限制 : 免費版資源 : 10個 / 付費版資源 : 25個 ▶ 項目範圍自訂維度(item scope)情境舉例以這一個商品舉例，右邊 items 陣列中的參數(item_name、item_id、price 等)都屬於 GA4 的預設項目範圍維度。 若想多追蹤杯子的容量，GA4 預設的項目範圍維度又沒有提供對應參數，這時候，就可以自訂一個項目範圍的自訂維度，Datalayer 調整後如下圖，新增的參數一定要放在 items 陣列中。 ▶ 項目範圍自訂維度(item scope)要如何在 GA4 中設定 ?確認有把自訂的參數送到 GA4 後，接下來就是要在 GA4 中設定自訂維度，設定路徑 : 管理(左下角齒輪) &gt; 自訂定義 &gt; 建立自訂維度(藍底按鈕) &gt; 範圍選 : 項目 &gt; 按下儲存可參考以下圖片，依序設定。 (下圖)記得範圍要選「項目」，項目參數需要填寫您在網站中傳送的參數名稱，以本次範例為例，則是填入 capacity (並非照填寫 capacity) 。 (下圖)儲存後，會出現範圍為「項目」的自訂維度。 ▶ 項目範圍自訂維度(item scope)在 GA4 探索報表中的呈現目前還無法在預設報表中，透過次要維度或是利用自訂報表功能拉取項目範圍維度，所以設定完的項目範圍自訂維度無法呈現在電子商務報表中，只能在探索報表使用，這部分較可惜，希望未來能更新上去。 補充提醒，電子商務相關的維度都只能搭配使用部分指標，所以建議先拉取項目範圍的維度後，再選擇指標(無法使用的指標會被反灰)。 此外Looker Studio 中也無法拉取項目範圍的自訂維度，以上的限制待未來更新後，再分享給大家~","link":"/2023/04/16/ga/ga4_share_0416/"},{"title":"GA4 vs GA3 來源/媒介 BigQuery 欄位解析","text":"👉 文章內容深度 : 3/5顆星👉 適用對象 : 有使用 BigQuery 製作來源/媒介報表 ▶ 什麼是來源/媒介 ? 簡單來說就是判斷這個流量從哪邊來? 是從 Google 搜尋引擎進入網站還是從 FB 粉專進入網站。以下為 GA3 &amp; GA4 的來源/媒介報表路徑 GA3 : 獲客 &gt; 所有流量 &gt; 來源/媒介 GA4 : 獲客 &gt; 流量開發 : 工作階段預設管道分組 (如下圖) ▶ GA3 vs. GA4 BigQuery 來源/媒介欄位比較表GA3 時代，從 BigQuery 中提取來源/媒介數據時，會使用欄位「trafficSource.source」&amp;「trafficSource.medium」，這是沒有錯的!這兩個欄位代表的是每次進站的渠道。&lt;附上 GA3 匯出 BigQuery 的結構定義&gt; 當看到 GA4 匯出到 BigQuery 的 Dataset 中看到「traffic_source.source」&amp;「traffic_source.medium」時，心中是不是無比喜悅，就是他惹 :100: 但是! 現在我們來看一下 Google 的官方文件說明(附上截圖&amp;文件)，補充:這兩個欄位會對應到 GA4 維度為「最初招攬到使用者的來源/媒介」 traffic_source.source : 初次招攬到使用者的聯播網名稱。 traffic_source.medium : 初次招攬到使用者的媒介名稱。 「初次招攬」指的是第一次進到網站的使用者是從哪個渠道進入網站，是 FB 廣告還是 Google 自然搜尋等等。舉例來說 :小明點了 Google 廣告，第一次進到網站中，那欄位值會如下 traffic_source.source : google traffic_source.medium : cpc 那小明隔天從 LINE 官方帳號進入網站，那欄位值是什麼?值還是一樣的 ! 因為「traffic_source.source 和 traffic_source.medium 這兩個欄位就是這兩個欄位僅記錄用戶首次訪問網站時的來源媒介 traffic_source.source : google traffic_source.medium : cpc ▶那第2次的來源媒介要怎麼取得?GA4 的數據模型是由事件組成，所以每個 event_name 對應一個資料列。event_name = page_view 指的就是每一次的網站瀏覽，所以第二次進站的來源媒介，會出現在事件名為 page_view 的資料列中，包含 source 和 medium 參數。 ▶2種情境與對應值，分享給大家情境1 :小明從 Google 自然搜尋第1次進站到首頁，點了站內 UTM(Urchin Tracking Module) 到活動頁 下表為 BQ 中的資料列示意 event_date event_name event_params.key event_params_value.string_value traffic_source.source traffic_source.medium 20230222 first_visit page_location 首頁網址 google organic 20230222 session_start page_location 首頁網址 google organic 20230222 page_view page_location 首頁網址 google organic source google medium organic 20230222 page_view page_location 站內UTM活動頁 google organic source Amy1 medium Test1 情境2 : 延續情境1，隔天小明點了 FB 粉專的貼文進入了網站商品頁，粉專貼文的連結有帶 UTM 為 Facebook / post下表為 BQ 中的資料列示意 event_date event_name event_params.key event_params_value.string_value traffic_source.source traffic_source.medium 20230223 session_start page_location 商品頁 google organic 20230223 page_view page_location 商品頁 google organic source Facebook medium post 結論 : traffic_source 欄位僅記錄用戶首次訪問網站時的來源媒介，不會因未來用戶進入網站的渠道而改變其值。附上查詢 SQL 12SELECT event_date,event_name, event_params, traffic_source.source, traffic_source.mediumFROM `你的工作表名稱`","link":"/2023/04/20/ga/ga4_share_0420/"}],"tags":[],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Google Analytics","slug":"Google-Analytics","link":"/categories/Google-Analytics/"}]}
{"pages":[{"title":"","text":"google-site-verification: google54765e92939cdff8.html","link":"/google54765e92939cdff8.html"},{"title":"關於我","text":"前 Notes Domino 工程師（相信大部分人都沒聽過，這個東西年紀比我還大XD）目前是前端工程師這個部落格主要會分享我平常在工作上使用的技術或是自己玩過的東西內容包含我遇到的問題、解法或我對該技術的理解或看法如有錯誤再請發現問題的有緣人不吝指教！","link":"/about/index.html"}],"posts":[{"title":"Angular Lazy Loading","text":"在 Angular 應用程式一載入時，預設會將所有的 Module 一次全部載入，但如果今天應用程式規模很大，或是某些 Module 中需要載入的東西過多，就會拖到整個應用程式的載入時間。 為了解決這個問題，Angular 有針對 Module 提供 Lazy Loading 的功能，簡單來說就是當需要此 Module 的時候再進行載入，如此就不會影響到整個應用程式的效能。 實現方式透過 Angular Router 中內建的功能即可實現，步驟如下： 修改app-routing.module.ts 123456const routes: Routes = [ { path: 'customers', loadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule) }]; 利用loadChildren這個屬性，我們就可以透過 import 將我們想要 lazy loading 的 Module，在應用程式觸發到path中定義的路由(在這個例子中就是/customers)的時候將 CustomersModule 進行載入。 修改customers.module.ts 1234567891011import { CustomersRoutingModule } from './customers-routing.module';@NgModule({ declarations: [ CustomersComponent ], imports: [ CommonModule, CustomersRoutingModule ]}) 額外新增customers-routing.module.ts，並新增到 CustomersModule 的 imports 中，我們會將關於此 Module 下 Router 的設定拆出來放在這個檔案中。 新增customers-routing.module.ts 123456789101112const routes: Routes = [ { path: 'info', component: CustomersComponent }];@NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule]})export class CustomersRoutingModule { } 這邊我們就可以定義在子路徑下要載入哪個 Component，最終的路徑會是原本app-routing.module.ts中定義的path加上這邊定義的path，以上例來說就會是在/customers/info下讀取到 CustomersComponent。這邊要注意需要用forChild來定義子路由。 透過指令建立如果我們在一開始就決定要使用 lazy loading 的方式載入 Module，也可以選擇用以下指令直接建立好上述的元件： 1ng generate module customers --route customers --module app.module 實驗我們可以在customers.components.ts中加上console.log來實驗是否有 lazy loading 12345678export class CustomersComponent implements OnInit { constructor() { } ngOnInit() { console.log(\"Customers Component Init\"); }} 讀取 http://localhost:4200 讀取 http://localhost:4200/customers 注意事項 如果 Module 需要 lazy loading，需注意app.module.ts裡面不可以 import 到這個 Module，否則還是會在應用程式啟動時就載入。","link":"/2022/05/29/angular-lazy-loading/"},{"title":"探討 Angular Module","text":"Angular 本身的設計概念就是使用模組化的機制，Module (模組) 是組成 Angular 應用程式的基本單位，每個 Angular 專案最開始都會有一個模組當作程式進入點，稱為根模組(Root Module) 。透過 Angular CLI 創建的專案會將此根模組命名為AppModule，並放在app.module.ts檔案中。 也可以將有相同特性的功能拆出來，組合成不同的模組，各個模組間依程式架構相互引用，組合成 Angular 應用程式。模組中可以透過設定的方式，定義此模組中包含的 components、directives、pipes 等，以及其他與模組相關的屬性，以下我們就來研究一下 Angular Module 的使用方式以及使用情境。 組成12345678910@NgModule({ declarations: [ AppComponent, ], imports: [ BrowserModule, ], providers: [], bootstrap: [AppComponent]}) 定義模組的檔案中會包含@NgModule，用來定義模組的設定。主要包含以下幾個屬性： declarations用來宣告此模組中包含的 components、directives、pipes。 12345declarations: [ UserComponent, CustomPipe, FileDirective],; 若使用ng generate 指令來產生物件，Angular CLI 會自動幫你把物件加入 declarations 中。 imports想要額外載入的 module，載入後就可以使用該 module 中 exports 的物件。 1234imports: [ BrowserModule, UserModule], 如上例，只要 import UserModule，模組內就可以使用 UserModule 中 export 的所有物件。 根模組必須要 import BrowserModule。 其他模組必須要 import CommonModule。 只要是用 CLI 建立的，上述兩項都會自動 import。 exports要匯出給其他模組使用的物件。 12345678declarations: [ UserComponent, CustomPipe, FileDirective],;exports: [ UserComponent], 要 export 的物件必須存在於 declarations 或 import 的 Module 中才可以。 上例 export 的只有 UserComponent，因此引入此 module 的模組只可使用 UserComponent。 providers宣告可以依賴注入的 service，整個應用程式都可以使用到此處宣告的 service。 123providers: [ UserService], 關於 providers 會再整理一篇文章進行探討。 bootstrap1bootstrap: [AppComponent], 定義根元件，作為應用程式啟動後預設讀取的元件，只有根模組需要定義此屬性，一般不太需要更動。 使用情境Module 用法除了最基本會有的根模組(Root Module) 外，常見的還有以下兩種用法： Feature Module其實就是最常見、第一個會想到使用 Module 的情境。將應用程式中你認為可以額外拆出來撰寫成一個功能的程式片段，拆出來成為一個 Module，就會稱它為Feature Module。 例如假設今天要實作一個網頁聊天室，聊天室可以傳送的訊息種類分為文字、檔案、圖片、貼圖等，我們就可以把傳送的「訊息」 拆一個 MessageModule，裡面包含 TextComponent、FileComponent、ImageComponent … 與其他串接的 Service 等。 Shared Module在 Angular 中常常會遇到很多物件(component、directive、pipe)一直被重複使用，此時為了不讓這些物件散落各地，還要讓 Module 一直引用來引用去，通常可以建立一個Shared Module來統一管理這些物件，要使用這些物件的 Module 只需要匯入一個Shared Module就可以了。 12345678910111213@NgModule({ declarations: [ TableComponent, PagerComponent, PaginationComponent ], exports: [ TableComponent, PagerComponent, PaginationComponent ],})export class SharedModule {} 如上例，其他模組只需要 import SharedModule 就可以使用裡面的所有物件。","link":"/2022/05/28/angular-module/"},{"title":"Angular 取得元素 offsetWidth 時有誤解法","text":"今天在工作上遇到一個問題，我有一個功能執行時會切換兩個 Angular Component 的顯示，當切換到其中一個 Component 時，我會去抓取當下它的 offsetWidth 做運算使用，但抓這個 offsetWidth 卻憑空少了15px，後來在找了一段時間終於找到原因，在這邊以一個簡化過的例子紀錄一下。 範例連結：https://stackblitz.com/edit/angular-ivy-bmpsfk 問題假設有一個按鈕，點擊之後可依狀態顯示不同的 Component。 12345678&lt;div class=\"container\"&gt; &lt;app-first *ngIf=\"visibleComponent === 'first'; else second\"&gt;&lt;/app-first&gt; &lt;ng-template #second&gt; &lt;app-second&gt;&lt;/app-second&gt; &lt;/ng-template&gt;&lt;/div&gt;&lt;button (click)=\"switch()\"&gt;switch&lt;/button&gt; 在 first component 中我們嘗試取得該元素的offsetWidth。 1&lt;div #content&gt;first component&lt;/div&gt; 12345...ngAfterViewInit() { console.log('content width: ', this.content.nativeElement.offsetWidth);}... 結果在當由 second 切換到 first 時，取得的 offsetWidth 為624px，但實際應為639px，少了15px。 原因經過測試後發現當有載入BrowserAnimationsModule才會發生此問題，且是 second component 中有 scroll bar 的原因，導致在取得 offsetWidth 時少了 15px。 但明明我是在 first component 中取 offsetWidth 阿？怎麼會吃到 scroll bar？ 原來是在 ngAfterViewInit 執行的當下子 Component 的畫面會比父 Component 還早運算，我們 ngIf 的條件是寫在父 Component 進行判斷，所以當下吃到的父層寬度還會保留在切換到另一個 Component 之前。 子 Component 的 ngAfterViewInit 也會比父 Component 的同一個事件還早執行。 由於 second component 多了 scroll bar，且在載入BrowserAnimationsModule時 scroll bar 會被算成 15px 的空間，所以在取得 offsetWidth 會少了 scroll bar 佔去的寬度。 解法由於是執行順序的問題，所以最簡單的解法就是透過setTimeout將取得 offsetWidth 的動作強制移動置 event loop 的最後執行。 12345678910ngAfterViewInit() { console.log('content width: ', this.content.nativeElement.offsetWidth); setTimeout(() =&gt; { console.log( 'content width after: ', this.content.nativeElement.offsetWidth ); });} 執行結果 目前只有嘗試到這個方式，若有找到更好的寫法會再更新。","link":"/2022/06/01/angular-offsetwidth-bug/"},{"title":"position:sticky 遇到 overflow 時失效解法","text":"今天在處理將 table 表頭凍結在最上方時，找到了使用position: sticky的方式解決，但若我要同時在小畫面時讓這個 table 的 X 軸能夠有 scroll bar 卻出現了問題，以下紀錄一下問題原因與解決方式。 範例連結：https://codepen.io/andyhung0723/pen/YzeOovW 問題假設我有一個 table，若我想將它的表頭凍結在最上方不動，可以使用position: sticky： 1234.table-sticky .th { position: sticky; top: 0;} 若在小畫面時想要此 table 不要撐開整體寬度，一般會在外層使用overflow-x: auto來讓 X 軸產生 scroll bar： 123.table-sticky-container { overflow-x: auto;} 此時就會發現原本position: sticky的凍結效果卻失效了。 原因經測試發現只要position: sticky上所有階層的父元素只要有一個的overflow值是visible以外的其他值，就會導致失效。 解法目前單純使用 CSS 貌似沒有解法，因此我使用 JavaScript 的 scroll 事件來動態 transform 表頭的位置來解決，程式碼如下： 12345678910111213141516171819202122window.addEventListener('scroll', function(event) { var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var stickyTables = document.querySelectorAll('.table-sticky'); for(var i = 0 ; i &lt; stickyTables.length ; i++) { var thead = stickyTables[i].querySelector('thead'); var offsetTop = stickyTables[i].offsetTop; var offsetHeight = stickyTables[i].offsetHeight - thead.offsetHeight; var transformY = getTranslateY(thead); if(scrollTop &gt;= offsetTop &amp;&amp; scrollTop &lt;= offsetTop + offsetHeight) { transformY = scrollTop - offsetTop; }else if(scrollTop &lt; offsetTop){ transformY = 0; } thead.style.transform = 'translateY('+ transformY +'px)'; } });function getTranslateY(element) { var style = window.getComputedStyle(element); var matrix = new WebKitCSSMatrix(style.transform); return matrix.m42;}","link":"/2022/06/08/position-sticky-issue/"}],"tags":[],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"}]}
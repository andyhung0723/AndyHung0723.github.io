{"pages":[{"title":"關於我","text":"資工系畢業第一份工作是大學時期實習的公司第二份工作是上面那份的主管跳出來成立的公司做的技術為 Notes Domino （相信大部分人都沒聽過，這個東西年紀比我還大XD）雖然已經做了五年 Domino但因為技術實在太老所以還是轉換跑道了目前是前端工程師這個部落格主要會分享我平常在工作上或是自己玩過的東西內容是我遇到的問題/解法或我對該技術的理解或許可能會有錯誤的情況有緣人發現問題的話再請不吝指教，大家一起進步！","link":"/about/index.html"}],"posts":[{"title":"Angular Lazy Loading","text":"在 Angular 應用程式一載入時，預設會將所有的 Module 一次全部載入，但如果今天應用程式規模很大，或是某些 Module 中需要載入的東西過多，就會拖到整個應用程式的載入時間。 為了解決這個問題，Angular 有針對 Module 提供 Lazy Loading 的功能，簡單來說就是當需要此 Module 的時候再進行載入，如此就不會影響到整個應用程式的效能。 實現方式透過 Angular Router 中內建的功能即可實現，步驟如下： 修改app-routing.module.ts const routes: Routes = [ { path: 'customers', loadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule) } ]; 利用loadChildren這個屬性，我們就可以透過 import 將我們想要 lazy loading 的 Module，在應用程式觸發到path中定義的路由(在這個例子中就是/customers)的時候將 CustomersModule 進行載入。 修改customers.module.ts import { CustomersRoutingModule } from './customers-routing.module'; @NgModule({ declarations: [ CustomersComponent ], imports: [ CommonModule, CustomersRoutingModule ] }) 額外新增customers-routing.module.ts，並新增到 CustomersModule 的 imports 中，我們會將關於此 Module 下 Router 的設定拆出來放在這個檔案中。 新增customers-routing.module.ts const routes: Routes = [ { path: 'info', component: CustomersComponent } ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule] }) export class CustomersRoutingModule { } 這邊我們就可以定義在子路徑下要載入哪個 Component，最終的路徑會是原本app-routing.module.ts中定義的path加上這邊定義的path，以上例來說就會是在/customers/info下讀取到 CustomersComponent。這邊要注意需要用forChild來定義子路由。 透過指令建立如果我們在一開始就決定要使用 lazy loading 的方式載入 Module，也可以選擇用以下指令直接建立好上述的元件： ng generate module customers --route customers --module app.module 實驗我們可以在customers.components.ts中加上console.log來實驗是否有 lazy loading export class CustomersComponent implements OnInit { constructor() { } ngOnInit() { console.log(\"Customers Component Init\"); } } 讀取 http://localhost:4200 讀取 http://localhost:4200/customers 注意事項 如果 Module 需要 lazy loading，需注意app.module.ts裡面不可以 import 到這個 Module，否則還是會在應用程式啟動時就載入。","link":"/2022/05/29/angular-lazy-loading/"},{"title":"探討 Angular Module","text":"Angular 本身的設計概念就是使用模組化的機制，Module (模組) 是組成 Angular 應用程式的基本單位，每個 Angular 專案最開始都會有一個模組當作程式進入點，稱為根模組(Root Module) 。透過 Angular CLI 創建的專案會將此根模組命名為AppModule，並放在app.module.ts檔案中。 也可以將有相同特性的功能拆出來，組合成不同的模組，各個模組間依程式架構相互引用，組合成 Angular 應用程式。模組中可以透過設定的方式，定義此模組中包含的 components、directives、pipes 等，以及其他與模組相關的屬性，以下我們就來研究一下 Angular Module 的使用方式以及使用情境。 組成@NgModule({ declarations: [ AppComponent, ], imports: [ BrowserModule, ], providers: [], bootstrap: [AppComponent] }) 定義模組的檔案中會包含@NgModule，用來定義模組的設定。主要包含以下幾個屬性： declarations用來宣告此模組中包含的 components、directives、pipes。 declarations: [ UserComponent, CustomPipe, FileDirective ],; 若使用ng generate 指令來產生物件，Angular CLI 會自動幫你把物件加入 declarations 中。 imports想要額外載入的 module，載入後就可以使用該 module 中 exports 的物件。 imports: [ BrowserModule, UserModule ], 如上例，只要 import UserModule，模組內就可以使用 UserModule 中 export 的所有物件。 根模組必須要 import BrowserModule。 其他模組必須要 import CommonModule。 只要是用 CLI 建立的，上述兩項都會自動 import。 exports要匯出給其他模組使用的物件。 declarations: [ UserComponent, CustomPipe, FileDirective ],; exports: [ UserComponent ], 要 export 的物件必須存在於 declarations 或 import 的 Module 中才可以。 上例 export 的只有 UserComponent，因此引入此 module 的模組只可使用 UserComponent。 providers宣告可以依賴注入的 service，整個應用程式都可以使用到此處宣告的 service。 providers: [ UserService ], 關於 providers 會再整理一篇文章進行探討。 bootstrapbootstrap: [AppComponent], 定義根元件，作為應用程式啟動後預設讀取的元件，只有根模組需要定義此屬性，一般不太需要更動。 使用情境Module 用法除了最基本會有的根模組(Root Module) 外，常見的還有以下兩種用法： Feature Module其實就是最常見、第一個會想到使用 Module 的情境。將應用程式中你認為可以額外拆出來撰寫成一個功能的程式片段，拆出來成為一個 Module，就會稱它為Feature Module。 例如假設今天要實作一個網頁聊天室，聊天室可以傳送的訊息種類分為文字、檔案、圖片、貼圖等，我們就可以把傳送的「訊息」 拆一個 MessageModule，裡面包含 TextComponent、FileComponent、ImageComponent … 與其他串接的 Service 等。 Shared Module在 Angular 中常常會遇到很多物件(component、directive、pipe)一直被重複使用，此時為了不讓這些物件散落各地，還要讓 Module 一直引用來引用去，通常可以建立一個Shared Module來統一管理這些物件，要使用這些物件的 Module 只需要匯入一個Shared Module就可以了。 @NgModule({ declarations: [ TableComponent, PagerComponent, PaginationComponent ], exports: [ TableComponent, PagerComponent, PaginationComponent ], }) export class SharedModule {} 如上例，其他模組只需要 import SharedModule 就可以使用裡面的所有物件。","link":"/2022/05/28/angular-module/"},{"title":"Angular 取得元素 offsetWidth 時有誤解法","text":"今天在工作上遇到一個問題，我有一個功能執行時會切換兩個 Angular Component 的顯示，當切換到其中一個 Component 時，我會去抓取當下它的 offsetWidth 做運算使用，但抓這個 offsetWidth 卻憑空少了15px，後來在找了一段時間終於找到原因，在這邊以一個簡化過的例子紀錄一下。 範例連結：https://stackblitz.com/edit/angular-ivy-bmpsfk 問題假設有一個按鈕，點擊之後可依狀態顯示不同的 Component。 &lt;div class=\"container\"&gt; &lt;app-first *ngIf=\"visibleComponent === 'first'; else second\"&gt;&lt;/app-first&gt; &lt;ng-template #second&gt; &lt;app-second&gt;&lt;/app-second&gt; &lt;/ng-template&gt; &lt;/div&gt; &lt;button (click)=\"switch()\"&gt;switch&lt;/button&gt; 在 first component 中我們嘗試取得該元素的offsetWidth。 &lt;div #content&gt;first component&lt;/div&gt; ... ngAfterViewInit() { console.log('content width: ', this.content.nativeElement.offsetWidth); } ... 結果在當由 second 切換到 first 時，取得的 offsetWidth 為624px，但實際應為639px，少了15px。 原因經過測試後發現當有載入BrowserAnimationsModule才會發生此問題，且是 second component 中有 scroll bar 的原因，導致在取得 offsetWidth 時少了 15px。 但明明我是在 first component 中取 offsetWidth 阿？怎麼會吃到 scroll bar？ 原來是在 ngAfterViewInit 執行的當下子 Component 的畫面會比父 Component 還早運算，我們 ngIf 的條件是寫在父 Component 進行判斷，所以當下吃到的父層寬度還會保留在切換到另一個 Component 之前。 子 Component 的 ngAfterViewInit 也會比父 Component 的同一個事件還早執行。 由於 second component 多了 scroll bar，且在載入BrowserAnimationsModule時 scroll bar 會被算成 15px 的空間，所以在取得 offsetWidth 會少了 scroll bar 佔去的寬度。 解法由於是執行順序的問題，所以最簡單的解法就是透過setTimeout將取得 offsetWidth 的動作強制移動置 event loop 的最後執行。 ngAfterViewInit() { console.log('content width: ', this.content.nativeElement.offsetWidth); setTimeout(() =&gt; { console.log( 'content width after: ', this.content.nativeElement.offsetWidth ); }); } 執行結果 目前只有嘗試到這個方式，若有找到更好的寫法會再更新。","link":"/2022/06/01/angular-offsetwidth-bug/"},{"title":"從 Junior 程式開發者的角度，我是如何看待 Notes Domino","text":"其實一直都很想寫一篇文章來分享我對它的看法，但始終找不到一個合適的角度與時間來做這件事，正好趁目前疫情在家工作期間來整理整理。 先科普一下，Notes Domino 以前是 IBM 旗下的一項產品，後來賣給了印度公司 HCL。主要的功能是郵件系統與用來作企業內部的一些簽核系統，有一點年紀的人可能都曾經用過它的郵件系統，直到今天（這個產品已經三十年了，比 Google 的年紀還大）台灣都還有公司在用它們郵件或系統。 我還是初出茅廬的菜鳥的時候就接觸到了 Notes Domino，還記得當初第一個練習是用它提供的開發介面「拉」出一個員工資料的表單，那時候心想：這個感覺找我家隔壁阿姨來也會做，這種工程師怎麼這麼無聊，完全不用寫程式的嗎？ 後來才知道如果遇到複雜一點的情況，背後可以再串接它原生提供的資料庫，也可以寫一些商業邏輯的程式來進階處理資料或流程。它還有提供讓你開發網頁的平台，透過拖拉或自行寫程式的方式，很快的就可以做好一個網頁，將前端的頁面與後端程式的部分全部整合在一個頁面上。 聽起來很不錯對吧？一開始我也是這麼想，特別是在工作上我最常接觸到的都是網頁相關的專案，那種快速建起一個網站系統的成就感，相信對於一個剛出社會的菜鳥工程師來說，真的是非常爽，就這樣過了好幾年，每天上班都沈浸在這套產品的方便與快速中。 直到某一年，因為公司專案正好不太忙，就在那段時間我開始去接觸了一下其他網頁前端的技術，才知道原來我正在用的技術是最陽春的，開發的手段也是難以維護的。畢竟它是一個非常有年紀的產品了（或許是買什麼爛什麼的 IBM 的問題？），加上本身整體架構的設計，不管是 Git 版控、前端框架(Angular / React / Vue)、npm 套件、Maven(它的後端是 Java)…等許多現今流行的技術或開發手段它都無法或不好使用，加上它的主要的開發平台 Domino Designer 的處理速度真的很慢，又很常無故崩潰，整體的 DX (Developer Experience) 很不好。其實還有很多點可以講，但怕太偏題，詳細可以看這篇，一樣是以我個人的角度整理的。 講到這邊，或許有些人會覺得「但你不是說它本來的開發速度很快，也很方便嗎？這樣就好了阿，為什麼一定要去追求什麼流行的技術？」但換個身份角度想，一個剛出社會的菜鳥，什麼技術都還不熟，又在程式開發這個技術更迭這麼快的領域，與其待在一個使用技術很舊、一段時間後想跳槽再換工作才發現自己前一份工作的東西都用不太上的公司，找一個使用主流技術的公司磨練不是對未來的發展更好嗎？ Notes Domino 這個領域，你 104 搜尋職缺的數量手指頭都算得出來，長遠來看它只會慢慢的消失在市場上。雖然現在 HCL 公司很積極的在優化整個產品，包括容器化技術、提高資料庫容量、外部 API 支援等等，但在台灣整體開發者族群數量偏少且老化，整個開發能量不足的情況下，無疑是一條看不到未來的道路。真的不是故意臭它，但實在不推薦新鮮人或 Junior 程式開發者進入這個產業。","link":"/2022/05/30/domino-opinion/"}],"tags":[],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"}]}